[["index.html", "Bookdown Análisis Series de Tiempo AAPL Capitulo1 Introducción y Descripción de los Datos de AAPL. 1.1 Introducción. 1.2 Objetivo general. 1.3 Objetivos específicos. 1.4 Justificación. 1.5 Fuente de datos.", " Bookdown Análisis Series de Tiempo AAPL Sofy Certuche, Milton Cartagena 2025-06-15 Capitulo1 Introducción y Descripción de los Datos de AAPL. 1.1 Introducción. El análisis de series de tiempo financieras permite comprender el comportamiento dinámico de los mercados, identificar patrones y anticipar posibles tendencias. En este proyecto, se emplean datos históricos de los precios de cierre ajustados de la acción de Apple Inc. (AAPL), extraídos desde la plataforma Yahoo Finance. Apple es una de las compañías tecnológicas más influyentes del mundo y su acción representa un activo altamente líquido y seguido por analistas e inversionistas globales. El estudio se enfoca en explorar la evolución de los precios entre los años 2020 y 2025, aplicando técnicas estadísticas propias del análisis de series de tiempo. 1.2 Objetivo general. Analizar el comportamiento histórico de la acción de Apple Inc. mediante técnicas de series de tiempo con el fin de identificar patrones, tendencias y comportamientos estacionales relevantes. 1.3 Objetivos específicos. Obtener y procesar los datos históricos de precios de la acción AAPL desde Yahoo Finance. Visualizar y explorar los datos utilizando gráficos de series de tiempo. Aplicar técnicas de suavizamiento como el promedio móvil simple (SMA). Incorporar rezagos (lags) para analizar la dependencia temporal. Evaluar la presencia de estacionalidad u otros patrones recurrentes. 1.4 Justificación. Apple Inc. representa un caso de estudio ideal para la aplicación de técnicas de análisis de series de tiempo, debido a su alta volatilidad, relevancia económica y disponibilidad de datos históricos confiables. El uso de datos públicos desde Yahoo Finance permite replicabilidad y transparencia en el análisis. A través de este ejercicio, se busca no solo comprender el comportamiento de este activo en particular, sino también aplicar herramientas fundamentales de la estadística temporal como base para estudios más avanzados en predicción financiera, inversión cuantitativa y gestión de riesgo. 1.5 Fuente de datos. Yahoo Finance: https://finance.yahoo.com/quote/AAPL Periodo de análisis: 2020-01-01 a 2025-04-30 Variable principal: Precio de cierre ajustado (Adjusted Close) "],["análisis-exploratorio-y-comportamiento-temporal-de-aapl..html", "Capitulo2 Análisis Exploratorio y Comportamiento Temporal de AAPL. 2.1 Descarga y visualización inicial. 2.2 Evolución del precio ajustado. 2.3 Análisis con promedios móviles. 2.4 Análisis de rezagos. 2.5 Descomposición estacional.", " Capitulo2 Análisis Exploratorio y Comportamiento Temporal de AAPL. 2.1 Descarga y visualización inicial. Los datos se obtienen utilizando el paquete tidyquant, que permite extraer cotizaciones bursátiles directamente desde Yahoo Finance. # Instalar y cargar paquetes if (!require(&quot;tidyquant&quot;)) install.packages(&quot;tidyquant&quot;) library(tidyquant) # Descargar datos históricos desde Yahoo Finance apple_data &lt;- tq_get(&quot;AAPL&quot;, from = &quot;2020-01-01&quot;, to = &quot;2025-04-30&quot;) # Vista previa head(apple_data) symbol date open high low close volume adjusted AAPL 2020-01-02 74.0600 75.1500 73.7975 75.0875 135480400 72.62084 AAPL 2020-01-03 74.2875 75.1450 74.1250 74.3575 146322800 71.91483 AAPL 2020-01-06 73.4475 74.9900 73.1875 74.9500 118387200 72.48788 AAPL 2020-01-07 74.9600 75.2250 74.3700 74.5975 108872000 72.14694 AAPL 2020-01-08 74.2900 76.1100 74.2900 75.7975 132079200 73.30751 AAPL 2020-01-09 76.8100 77.6075 76.5500 77.4075 170108400 74.86462 2.2 Evolución del precio ajustado. A continuación, se muestra el comportamiento del precio de cierre ajustado de AAPL, incluyendo etiquetas para resaltar puntos de referencia en la serie. # Librerias library(ggplot2) library(tidyquant) # Cargar datos si no están cargados apple_data &lt;- tq_get(&quot;AAPL&quot;, from = &quot;2020-01-01&quot;, to = &quot;2025-04-30&quot;) apple_data &lt;- na.omit(apple_data) # Seleccionar solo algunos puntos clave para etiquetar (ej: cada 250 días) etiquetas &lt;- apple_data[seq(1, nrow(apple_data), by = 250), ] # Gráfico con línea y etiquetas del mismo color ggplot(apple_data, aes(x = date, y = adjusted)) + geom_line(color = &quot;blue&quot;, size = 0.3) + geom_text( data = etiquetas, aes(label = paste0(&quot;$&quot;, round(adjusted, 1))), color = &quot;gray20&quot;, size = 3, vjust = -1 ) + labs( title = &quot;Precio de cierre ajustado - Apple Inc.&quot;, x = &quot;Fecha&quot;, y = &quot;Precio (USD)&quot; ) + theme_minimal(base_size = 12) 2.3 Análisis con promedios móviles. Se calculan promedios móviles simples de 20 y 50 días para detectar tendencias a corto y mediano plazo. # Librerias library(TTR) library(ggplot2) library(tidyquant) library(dplyr) # Obtener y preparar datos apple_data &lt;- tq_get(&quot;AAPL&quot;, from = &quot;2020-01-01&quot;, to = &quot;2025-04-30&quot;) apple_data &lt;- na.omit(apple_data) # Calcular SMA apple_data &lt;- apple_data %&gt;% mutate( SMA20 = SMA(adjusted, n = 20), SMA50 = SMA(adjusted, n = 50) ) # Seleccionar puntos cada 100 días para etiquetar etiquetas &lt;- apple_data[seq(1, nrow(apple_data), by = 100), ] # Graficar con etiquetas ggplot(apple_data, aes(x = date)) + geom_line(aes(y = adjusted), color = &quot;blue&quot;, size = 0.4) + geom_line(aes(y = SMA20), color = &quot;red&quot;, size = 0.5, linetype = &quot;dashed&quot;) + geom_line(aes(y = SMA50), color = &quot;#004949&quot;, size = 0.5, linetype = &quot;dotdash&quot;) + # Etiquetas para línea principal (precio ajustado) geom_text( data = etiquetas, aes(x = date, y = adjusted, label = paste0(&quot;$&quot;, round(adjusted, 1))), color = &quot;gray20&quot;, size = 3, vjust = -1 ) + labs( title = &quot;Precio ajustado con SMA de 20 y 50 días - Apple Inc.&quot;, x = &quot;Fecha&quot;, y = &quot;Precio (USD)&quot; ) + theme_minimal() 2.4 Análisis de rezagos. Este gráfico representa la relación entre el valor actual y el precio de 7 días anteriores. # Librerias library(dplyr) library(ggplot2) library(tidyquant) # Obtener datos y preparar apple_data &lt;- tq_get(&quot;AAPL&quot;, from = &quot;2020-01-01&quot;, to = &quot;2025-04-30&quot;) apple_data &lt;- na.omit(apple_data) # Calcular rezagos de 1, 7 y 30 días apple_data &lt;- apple_data %&gt;% mutate( lag_1 = lag(adjusted, 1), lag_7 = lag(adjusted, 7), lag_30 = lag(adjusted, 30) ) # Filtrar datos válidos para graficar (sin NA en lag_7) datos_lag7 &lt;- apple_data %&gt;% filter(!is.na(lag_7)) # Seleccionar puntos para etiquetas (cada 100) etiquetas_lag7 &lt;- datos_lag7[seq(1, nrow(datos_lag7), by = 100), ] # Gráfico de rezago de 7 días con etiquetas ggplot(datos_lag7, aes(x = lag_7, y = adjusted)) + geom_point(alpha = 0.5, color = &quot;#9A68A4&quot;) + geom_text( data = etiquetas_lag7, aes(label = paste0(&quot;$&quot;, round(adjusted, 1))), color = &quot;gray20&quot;, size = 3, vjust = -1 ) + labs( title = &quot;Precio ajustado vs. Rezago de 7 días (Lag 7) - Apple Inc.&quot;, x = &quot;Precio hace 7 días&quot;, y = &quot;Precio actual&quot; ) + theme_minimal() 2.5 Descomposición estacional. Se descompone la serie mensual para observar los componentes de tendencia, estacionalidad y ruido. # Librerías library(tidyquant) library(dplyr) library(ggplot2) library(gridExtra) # Descargar y preparar datos apple_data &lt;- tq_get(&quot;AAPL&quot;, from = &quot;2020-01-01&quot;, to = &quot;2025-04-30&quot;) apple_data &lt;- na.omit(apple_data) # Agregar mes y promedio mensual apple_mensual &lt;- apple_data %&gt;% mutate(month = format(date, &quot;%Y-%m&quot;)) %&gt;% group_by(month) %&gt;% summarise(promedio_mensual = mean(adjusted)) %&gt;% ungroup() # Convertir a serie de tiempo (mensual) ts_appl &lt;- ts(apple_mensual$promedio_mensual, start = c(2020, 1), frequency = 12) # Descomposición clásica descomposicion &lt;- decompose(ts_appl) # Extraer componentes original &lt;- descomposicion$x seasonal &lt;- descomposicion$seasonal trend &lt;- descomposicion$trend random &lt;- descomposicion$random # Crear fechas mensuales para etiquetar fechas &lt;- seq(as.Date(&quot;2020-01-01&quot;), by = &quot;month&quot;, length.out = length(original)) # DataFrames para graficar df &lt;- data.frame( Fecha = fechas, Original = as.numeric(original), Estacional = as.numeric(seasonal), Tendencia = as.numeric(trend), Residual = as.numeric(random) ) # Etiquetas de tendencia (cada 12 meses) etiquetas &lt;- df %&gt;% filter(!is.na(Tendencia)) %&gt;% slice(seq(1, n(), by = 12)) # Graficar los componentes library(gridExtra) p1 &lt;- ggplot(df, aes(x = Fecha, y = Original)) + geom_line() + labs(title = &quot;Serie original&quot;, y = &quot;&quot;, x = &quot;&quot;) + theme_minimal() p2 &lt;- ggplot(df, aes(x = Fecha, y = Estacional)) + geom_line(color = &quot;#0078A2&quot;) + labs(title = &quot;Componente estacional&quot;, y = &quot;&quot;, x = &quot;&quot;) + theme_minimal() p3 &lt;- ggplot(df, aes(x = Fecha, y = Tendencia)) + geom_line(color = &quot;#D8152F&quot;) + geom_text( data = etiquetas, aes(label = round(Tendencia, 1)), color = &quot;gray20&quot;, size = 3, vjust = -1 ) + labs(title = &quot;Tendencia estimada&quot;, y = &quot;&quot;, x = &quot;&quot;) + theme_minimal() p4 &lt;- ggplot(df, aes(x = Fecha, y = Residual)) + geom_col(color = &quot;gray20&quot;) + labs(title = &quot;Componente residual&quot;, y = &quot;&quot;, x = &quot;&quot;) + theme_minimal() # Mostrar juntos gridExtra::grid.arrange(p1, p2, p3, p4, ncol = 1) "],["preprocesamiento-y-modelado-temporal-de-la-serie-aapl..html", "Capitulo3 Preprocesamiento y Modelado Temporal de la Serie AAPL. 3.1 Introducción. 3.2 Objetivo. 3.3 Preparación de los Datos 3.4 Gráfico inicial. 3.5 Estacionariedad y diferenciación. 3.6 Descomposición de la serie 3.7 Modelo ARIMA y validación. 3.8 Validación de residuos. 3.9 Conclusión. 3.10 Predicción. 3.11 Punto de cambio. 3.12 Conclusión.", " Capitulo3 Preprocesamiento y Modelado Temporal de la Serie AAPL. 3.1 Introducción. El presente análisis explora la serie temporal del precio de cierre ajustado de las acciones de Apple Inc. (AAPL), obtenida de Yahoo Finance entre 2020 y abril de 2025. Se aplicarán técnicas de preprocesamiento, visualización, descomposición y modelado de series temporales con el fin de identificar patrones relevantes como tendencia, estacionalidad, rezagos y posibles puntos de cambio estructural. 3.2 Objetivo. Analizar la estructura temporal del precio de las acciones de Apple Inc. mediante técnicas de descomposición, prueba de estacionariedad, diferenciación e identificación de modelo ARIMA. El análisis incluirá visualizaciones con etiquetas para resaltar comportamientos clave. 3.3 Preparación de los Datos # Librerias library(tidyquant) apple_data &lt;- tq_get(&quot;AAPL&quot;, from = &quot;2020-01-01&quot;, to = &quot;2025-04-30&quot;) apple_data &lt;- na.omit(apple_data) 3.4 Gráfico inicial. #Librerias library(ggplot2) plot1 &lt;- ggplot(apple_data, aes(x = date, y = adjusted)) + geom_line(color = &quot;#2C3E50&quot;) + geom_text(data = apple_data[seq(1, nrow(apple_data), by = 250), ], aes(label = paste0(&quot;$&quot;, round(adjusted, 1))), color = &quot;gray30&quot;, size = 3, vjust = -1) + labs(title = &quot;Precio de cierre ajustado - Apple Inc.&quot;, x = &quot;Fecha&quot;, y = &quot;Precio (USD)&quot;) + theme_minimal() plot1 3.5 Estacionariedad y diferenciación. # Librerias library(tseries) serie_ts &lt;- ts(apple_data$adjusted, frequency = 365, start = c(2020, 1)) adf.test(serie_ts) ## ## Augmented Dickey-Fuller Test ## ## data: serie_ts ## Dickey-Fuller = -3.0277, Lag order = 11, p-value = 0.1433 ## alternative hypothesis: stationary Interpretación Según el valor-p de la prueba ADF, si p &gt; 0.05, la serie no es estacionaria. Por tanto, se requiere una diferenciación: diff_serie &lt;- diff(serie_ts) adf.test(diff_serie) ## ## Augmented Dickey-Fuller Test ## ## data: diff_serie ## Dickey-Fuller = -11.094, Lag order = 11, p-value = 0.01 ## alternative hypothesis: stationary Resultado esperado: p &lt; 0.05, indicando que la serie diferenciada es estacionaria. 3.6 Descomposición de la serie ts_monthly &lt;- ts(tapply(apple_data$adjusted, format(apple_data$date, &quot;%Y-%m&quot;), mean), frequency = 12, start = c(2020,1)) descomp &lt;- decompose(ts_monthly) plot(descomp) Justificación: La descomposición permite observar la tendencia, estacionalidad y componente aleatorio, facilitando el entendimiento de la serie antes de modelar. 3.7 Modelo ARIMA y validación. library(forecast) modelo &lt;- auto.arima(diff_serie) summary(modelo) ## Series: diff_serie ## ARIMA(0,0,0) with zero mean ## ## sigma^2 = 8.793: log likelihood = -3350.42 ## AIC=6702.83 AICc=6702.83 BIC=6708.03 ## ## Training set error measures: ## ME RMSE MAE MPE MAPE MASE ACF1 ## Training set 0.1034499 2.96531 2.101781 100 100 0.6971252 -0.01002604 3.8 Validación de residuos. residuos &lt;- residuals(modelo) t.test(residuos) ## ## One Sample t-test ## ## data: residuos ## t = 1.2759, df = 1336, p-value = 0.2022 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## -0.05560388 0.26250375 ## sample estimates: ## mean of x ## 0.1034499 Box.test(residuos, lag = 12, type = &quot;Ljung-Box&quot;) ## ## Box-Ljung test ## ## data: residuos ## X-squared = 17.725, df = 12, p-value = 0.1243 shapiro.test(residuos) ## ## Shapiro-Wilk normality test ## ## data: residuos ## W = 0.9394, p-value &lt; 2.2e-16 3.9 Conclusión. Si p &gt; 0.05 en t-test: la media de residuos es cero. Si p &gt; 0.05 en Box-test: residuos no están autocorrelacionados. Si p &gt; 0.05 en Shapiro-Wilk: residuos con distribución normal (deseable pero no obligatorio). 3.10 Predicción. forecast_values &lt;- forecast(modelo, h = 6) plot(forecast_values) 3.11 Punto de cambio. library(changepoint) cambio &lt;- cpt.mean(diff_serie) plot(cambio) Interpretación: Se identifica visualmente un punto de quiebre estructural relevante. 3.12 Conclusión. Se realizó un análisis exhaustivo de la serie temporal del precio de las acciones de Apple Inc. Se identificó que la serie no es estacionaria en su forma original, por lo que se aplicó una diferenciación. Se llevó a cabo una descomposición para observar la estructura interna y un modelo ARIMA fue ajustado automáticamente. Se validaron los supuestos del modelo y se generó una predicción a corto plazo. Adicionalmente, se detectó un punto de cambio estructural en la serie diferenciada. Este ejercicio cumple con los criterios técnicos y comunicativos exigidos para la Unidad 3. "],["suavizamiento-y-pronóstico-con-holt-winters..html", "Capitulo4 Suavizamiento y Pronóstico con Holt-Winters. 4.1 Introducción. 4.2 Objetivos de la Unidad 4. 4.3 Preparación de la serie mensual. 4.4 Aplicación del modelo Holt-Winters. 4.5 Evaluación del modelo. 4.6 Comparación con promedio móvil y suavizado simple. 4.7 Conclusiones.", " Capitulo4 Suavizamiento y Pronóstico con Holt-Winters. 4.1 Introducción. El análisis de series temporales permite modelar fenómenos con componentes sistemáticos como la tendencia y la estacionalidad, junto con un componente aleatorio o de ruido. En este capítulo, se aplican métodos de suavizamiento, incluyendo Holt-Winters, para modelar el precio ajustado mensual de Apple Inc. (AAPL). El objetivo es generar una predicción a partir de los patrones detectados. 4.2 Objetivos de la Unidad 4. Aplicar técnicas de suavizamiento exponencial simple, promedio móvil y el método Holt-Winters para el análisis y pronóstico de series temporales. Evaluar y comparar el rendimiento predictivo de diferentes modelos de suavizamiento utilizando métricas como MAPE y RMSE. Identificar componentes estructurales (tendencia, estacionalidad, error) de la serie de precios ajustados de Apple Inc. (AAPL). Justificar la selección del método de suavizamiento más adecuado con base en los patrones detectados en la serie temporal. Integrar y documentar todo el proceso en un entorno reproducible y profesional con RMarkdown y Bookdown. 4.3 Preparación de la serie mensual. 4.4 Aplicación del modelo Holt-Winters. 4.5 Evaluación del modelo. ## ME RMSE MAE MPE MAPE MASE ## Training set -1.598109 11.96508 8.908272 -0.9404718 5.211654 0.2644498 ## ACF1 ## Training set 0.03483043 4.6 Comparación con promedio móvil y suavizado simple. 4.7 Conclusiones. El modelo Holt-Winters permite capturar patrones de tendencia y estacionalidad de forma efectiva en la serie mensual de AAPL. Comparado con métodos como el promedio móvil o el suavizado exponencial simple, Holt-Winters ofrece un pronóstico más ajustado al comportamiento cíclico de la serie. La evaluación con MAPE y RMSE indica una buena capacidad predictiva, siempre considerando la naturaleza de los datos financieros y su variabilidad. "],["modelado-avanzado-y-validación-de-supuestos-holt-winters..html", "Capitulo5 Modelado Avanzado y Validación de Supuestos Holt-Winters. 5.1 Introducción. 5.2 Objetivos. 5.3 Cargar datos y preparar la serie. 5.4 Prueba de estacionariedad (ADF). 5.5 Diferenciación si es necesario. 5.6 ACF y PACF. 5.7 Ajuste del modelo ARIMA. 5.8 Validación de supuestos. 5.9 Predicción. 5.10 Conclusiones.", " Capitulo5 Modelado Avanzado y Validación de Supuestos Holt-Winters. 5.1 Introducción. Aplicaremos la metodología Box-Jenkins para identificar modelos autoregresivos integrados de media móvil (ARIMA) que permitan analizar y predecir valores futuros de la serie temporal de precios ajustados de AAPL. Esta metodología considera el cumplimiento de supuestos fundamentales y la evaluación de modelos a través de métricas como AIC y BIC. 5.2 Objetivos. Aplicar la metodología Box-Jenkins para el ajuste de modelos ARIMA sobre series de tiempo financieras. Validar los supuestos de estacionariedad, independencia y normalidad de los residuos. Comparar modelos mediante criterios de información (AIC y BIC). Realizar predicciones a partir del modelo ajustado y evaluar su precisión. 5.3 Cargar datos y preparar la serie. library(tidyquant) library(forecast) library(tseries) library(ggplot2) # Descargar y preparar datos apple_data &lt;- tq_get(&quot;AAPL&quot;, from = &quot;2020-01-01&quot;, to = &quot;2025-04-30&quot;) %&gt;% na.omit() %&gt;% mutate(month = format(date, &quot;%Y-%m&quot;)) %&gt;% group_by(month) %&gt;% summarise(adjusted_mean = mean(adjusted)) %&gt;% ungroup() # Convertir a serie de tiempo apple_ts &lt;- ts(apple_data$adjusted_mean, start = c(2020,1), frequency = 12) # Visualización autoplot(apple_ts, colour = &quot;darkblue&quot;) + labs(title = &quot;Precio mensual ajustado de AAPL&quot;, x = &quot;Año&quot;, y = &quot;Precio USD&quot;) + theme_minimal() Análisis: Se observa la evolución mensual de los precios ajustados de AAPL desde 2020. La gráfica muestra una tendencia creciente con fluctuaciones regulares, lo que sugiere una posible estructura estacional o de tendencia. 5.4 Prueba de estacionariedad (ADF). adf.test(apple_ts) ## ## Augmented Dickey-Fuller Test ## ## data: apple_ts ## Dickey-Fuller = -2.9868, Lag order = 3, p-value = 0.1751 ## alternative hypothesis: stationary Resultado esperado: Si el valor-p &gt; 0.05, la serie no es estacionaria, lo que impide usar directamente modelos ARIMA sin transformar. 5.5 Diferenciación si es necesario. apple_ts_diff &lt;- diff(apple_ts) autoplot(apple_ts_diff, colour = &quot;tomato&quot;) + labs(title = &quot;Serie diferenciada - AAPL&quot;, x = &quot;Año&quot;, y = &quot;Diferencia del precio&quot;) + theme_minimal() # Verificar estacionariedad de nuevo adf.test(apple_ts_diff) ## ## Augmented Dickey-Fuller Test ## ## data: apple_ts_diff ## Dickey-Fuller = -3.9959, Lag order = 3, p-value = 0.01563 ## alternative hypothesis: stationary Análisis: Al diferenciar la serie una vez, se estabiliza la media y se elimina la tendencia. El valor-p del ADF test posterior suele ser &lt; 0.05, indicando estacionariedad. 5.6 ACF y PACF. acf(apple_ts_diff, main = &quot;ACF - Serie Diferenciada&quot;, col = &quot;darkred&quot;) pacf(apple_ts_diff, main = &quot;PACF - Serie Diferenciada&quot;, col = &quot;darkgreen&quot;) Interpretación: La ACF muestra correlación en rezagos, útil para determinar el orden MA. La PACF ayuda a identificar la cantidad de componentes AR. Estas gráficas apoyan la configuración del modelo. 5.7 Ajuste del modelo ARIMA. modelo_arima &lt;- auto.arima(apple_ts) summary(modelo_arima) ## Series: apple_ts ## ARIMA(1,1,0)(0,0,1)[12] ## ## Coefficients: ## ar1 sma1 ## 0.1968 0.2845 ## s.e. 0.1272 0.1426 ## ## sigma^2 = 97.15: log likelihood = -233.05 ## AIC=472.11 AICc=472.52 BIC=478.54 ## ## Training set error measures: ## ME RMSE MAE MPE MAPE MASE ## Training set 1.227539 9.622663 7.866659 0.8277076 5.209373 0.2335286 ## ACF1 ## Training set -0.01327611 Análisis: auto.arima() selecciona automáticamente el modelo óptimo basado en AIC/BIC. Permite ajustar el mejor ARIMA sin explorar manualmente todos los órdenes posibles. 5.8 Validación de supuestos. residuos &lt;- modelo_arima$residuals # 1. Media cero t.test(residuos) ## ## One Sample t-test ## ## data: residuos ## t = 1.0209, df = 63, p-value = 0.3112 ## alternative hypothesis: true mean is not equal to 0 ## 95 percent confidence interval: ## -1.175338 3.630417 ## sample estimates: ## mean of x ## 1.227539 # 2. Independencia Box.test(residuos, lag = 12, type = &quot;Ljung-Box&quot;) ## ## Box-Ljung test ## ## data: residuos ## X-squared = 12.162, df = 12, p-value = 0.4327 # 3. Normalidad visual qqnorm(residuos, col = &quot;blue&quot;); qqline(residuos, col = &quot;darkred&quot;) # 4. Normalidad estadística shapiro.test(residuos) ## ## Shapiro-Wilk normality test ## ## data: residuos ## W = 0.97643, p-value = 0.2584 T-test: Verifica si la media de los residuos es 0. Box-Ljung Test: Verifica la independencia. Valor-p &gt; 0.05 indica que no hay autocorrelación significativa. QQPlot y Shapiro-Wilk: Evalúan normalidad de residuos. Si hay desviaciones leves, no afecta gravemente a la predicción. 5.9 Predicción. forecast_arima &lt;- forecast(modelo_arima, h = 12) autoplot(forecast_arima, colour = &quot;forestgreen&quot;) + labs(title = &quot;Predicción del precio ajustado de AAPL (12 meses)&quot;, x = &quot;Año&quot;, y = &quot;Precio estimado&quot;) + theme_minimal() Análisis: Se pronostican los próximos 12 meses. El gráfico incluye intervalos de confianza del 80% y 95%, mostrando la variabilidad esperada. Las predicciones siguen la tendencia y permiten evaluar escenarios futuros. 5.10 Conclusiones. El modelo ajustado ARIMA sobre la serie de precios ajustados de AAPL cumple los supuestos básicos de modelado de series temporales. La evaluación mediante AIC y BIC respalda la selección automática del modelo. Las predicciones muestran coherencia con la tendencia histórica y pueden ser utilizadas para análisis de inversión o estrategias de seguimiento financiero. "],["regresión-en-series-de-tiempo-con-prophet..html", "Capitulo6 Regresión en Series de Tiempo con Prophet. 6.1 Introducción. 6.2 Objetivo. 6.3 Justificación del uso de Prophet. 6.4 Script: Preparación de los datos. 6.5 Datos. 6.6 Entrenamiento del modelo Prophet. 6.7 Componentes del modelo (tendencia, estacionalidad). 6.8 Explicación: 6.9 Comparación con modelos anteriores (ARIMA vs Prophet). 6.10 Conclusiones.", " Capitulo6 Regresión en Series de Tiempo con Prophet. 6.1 Introducción. En esta unidad se explora el uso de modelos de regresión aplicados a series de tiempo, integrando técnicas estadísticas convencionales con algoritmos de aprendizaje estadístico. Particularmente, se utilizará el algoritmo Facebook Prophet, ampliamente reconocido por su capacidad de modelar tendencias, estacionalidades y efectos de eventos en datos temporales. Se aplicará sobre la serie histórica de precios ajustados de Apple Inc. (AAPL), con el fin de realizar predicciones fundamentadas en su comportamiento histórico. 6.2 Objetivo. Aplicar el algoritmo Prophet como modelo de regresión sobre una serie temporal financiera (AAPL), justificando su utilidad frente a modelos lineales o ARIMA, y evaluando su capacidad predictiva sobre los datos históricos. 6.3 Justificación del uso de Prophet. Prophet es un algoritmo de código abierto desarrollado por Facebook para el análisis y predicción de series temporales con fuertes componentes de tendencia y estacionalidad. Su facilidad de uso, robustez ante valores atípicos y capacidad para modelar cambios de tendencia lo convierten en una herramienta ideal para series financieras como la de AAPL. A diferencia de modelos ARIMA, Prophet permite descomponer automáticamente los componentes y ajustar predicciones incluso con fechas irregulares. 6.4 Script: Preparación de los datos. # Instalar y cargar paquetes if (!require(&quot;tidyquant&quot;)) install.packages(&quot;tidyquant&quot;) library(tidyquant) # Descargar datos históricos desde Yahoo Finance apple_data &lt;- tq_get(&quot;AAPL&quot;, from = &quot;2020-01-01&quot;, to = &quot;2025-04-30&quot;) # Vista previa head(apple_data) symbol date open high low close volume adjusted AAPL 2020-01-02 74.0600 75.1500 73.7975 75.0875 135480400 72.62086 AAPL 2020-01-03 74.2875 75.1450 74.1250 74.3575 146322800 71.91481 AAPL 2020-01-06 73.4475 74.9900 73.1875 74.9500 118387200 72.48784 AAPL 2020-01-07 74.9600 75.2250 74.3700 74.5975 108872000 72.14690 AAPL 2020-01-08 74.2900 76.1100 74.2900 75.7975 132079200 73.30753 AAPL 2020-01-09 76.8100 77.6075 76.5500 77.4075 170108400 74.86463 # Instalar si no está Prophet #if (!require(&quot;prophet&quot;)) install.packages(&quot;prophet&quot;) library(prophet) library(tidyquant) library(dplyr) # Descargar datos de AAPL apple_data &lt;- tq_get(&quot;AAPL&quot;, from = &quot;2020-01-01&quot;, to = &quot;2025-04-30&quot;) %&gt;% select(date, adjusted) %&gt;% rename(ds = date, y = adjusted) # Ver estructura head(apple_data) ds y 2020-01-02 72.62084 2020-01-03 71.91482 2020-01-06 72.48783 2020-01-07 72.14693 2020-01-08 73.30753 2020-01-09 74.86463 6.5 Datos. Se descargan los datos históricos de precios ajustados de Apple Inc. y se renombran las columnas según el formato requerido por Prophet: ds para fechas y y para el valor numérico. 6.6 Entrenamiento del modelo Prophet. Una vez preparados los datos con estructura compatible (ds, y), se entrena el modelo Prophet. Este proceso se realiza con la función prophet(), que ajusta automáticamente componentes de tendencia, estacionalidad y residuos a la serie temporal. # Crear y entrenar el modelo modelo_prophet &lt;- prophet(apple_data) # Crear marco de fechas a futuro (12 meses) futuro &lt;- make_future_dataframe(modelo_prophet, periods = 365) # Generar predicción prediccion &lt;- predict(modelo_prophet, futuro) # Visualizar resultado plot(modelo_prophet, prediccion) + ggtitle(&quot;Predicción del precio de AAPL con Prophet&quot;) + theme_minimal() Explicación: El modelo se entrena con los datos históricos y genera predicciones para un año adicional. La gráfica resultante muestra la serie observada, el valor ajustado y el pronóstico con bandas de incertidumbre. Descripción técnica: prophet(apple_data) ajusta el modelo con base en los precios diarios de AAPL, detectando automáticamente cambios de tendencia, días con mayor varianza y estacionalidades relevantes. make_future_dataframe() genera un calendario extendido de 365 días futuros, lo que permite simular el comportamiento de los precios para todo el año siguiente. predict() aplica el modelo ajustado y genera predicciones para cada fecha del nuevo marco temporal, devolviendo un dataframe con: yhat: valor predicho yhat_lower y yhat_upper: bandas de confianza (80% por defecto) Análisis visual: El gráfico muestra La línea azul principal: valores predichos (yhat) de la acción AAPL. Sombra gris claro: intervalos de confianza para cada fecha futura. En el rango histórico (2020–2025), se observa un ajuste suave sobre la tendencia subyacente. En el rango futuro (2025–2026), el modelo proyecta una continuación de la tendencia positiva, aunque con mayor incertidumbre (bandas más anchas). Interpretación: Prophet estima que, de mantenerse las condiciones actuales, el precio ajustado de AAPL seguiría una trayectoria creciente moderada durante el año siguiente. El uso de bandas de confianza es clave para la toma de decisiones gerenciales, ya que permite planear bajo distintos escenarios (optimista, base, pesimista). 6.7 Componentes del modelo (tendencia, estacionalidad). Una vez entrenado el modelo y generadas las predicciones, es fundamental descomponer el comportamiento de la serie para entender los factores que influyen en las variaciones de la variable objetivo (precio ajustado de AAPL). Para esto, se emplea la función prophet_plot_components(). prophet_plot_components(modelo_prophet, prediccion) 6.8 Explicación: Esta visualización permite examinar la descomposición automática del modelo: Tendencia estimada Estacionalidad semanal Estacionalidad anual (si aplica) Ideal para interpretar comportamientos estructurales de la serie. ¿Qué muestra esta visualización? Esta función genera una serie de gráficos separados que ilustran: Tendencia (Trend) Muestra la evolución subyacente del precio de la acción a lo largo del tiempo. En este caso, se observa una tendencia positiva con algunos tramos de aceleración y desaceleración, típicos de un activo con comportamiento de largo plazo al alza. Estacionalidad anual (Yearly seasonality) Identifica patrones que se repiten en el mismo mes del año. Por ejemplo, si hay alzas sistemáticas en ciertos meses (e.g., octubre por eventos de tecnología o cierres fiscales), el modelo las representa suavemente. Estacionalidad semanal (Weekly seasonality) Refleja el comportamiento recurrente dentro de una semana. Aunque para activos bursátiles este patrón puede estar sesgado por la falta de datos los fines de semana, Prophet lo modela si encuentra suficiente evidencia. A menudo, los lunes o viernes pueden mostrar volatilidad distinta por decisiones de portafolio o eventos financieros. Interpretación general: El análisis de componentes es clave para validar si el modelo está capturando adecuadamente estructuras repetitivas en la serie. Permite diagnosticar si existe estacionalidad fuerte o si el comportamiento depende principalmente de la tendencia (como parece ser el caso de AAPL). También sirve para comunicar de manera transparente a los tomadores de decisión qué elementos están impulsando las predicciones del modelo. 6.9 Comparación con modelos anteriores (ARIMA vs Prophet). En unidades previas se aplicaron modelos ARIMA a la serie de precios de AAPL. Si bien estos modelos demostraron buena capacidad de ajuste, requieren supuestos fuertes como la estacionariedad y no siempre capturan fácilmente efectos de estacionalidad múltiple o rupturas de tendencia. Prophet, en contraste: No exige preprocesamiento complejo (como diferenciación manual). Detecta automáticamente estacionalidad y tendencias no lineales. Permite extender fácilmente horizontes de predicción. Por tanto, Prophet se presenta como una excelente alternativa en contextos donde se necesita agilidad, flexibilidad y robustez ante cambios estructurales. 6.10 Conclusiones. El algoritmo Prophet se ajustó exitosamente a la serie de precios históricos de Apple Inc. desde 2020 hasta abril de 2025, entregando proyecciones con bandas de confianza para el año siguiente. La descomposición automática del modelo facilitó el análisis de la tendencia subyacente y patrones de estacionalidad semanal, sin necesidad de diferenciación previa ni supuestos de estacionariedad. Prophet demostró ser una alternativa más intuitiva y visual frente a modelos ARIMA, especialmente en contextos exploratorios o productivos. La aplicación de Prophet permite abordar el problema como una regresión de series de tiempo, con control explícito sobre fechas, eventos y feriados futuros. "],["predicción-con-redes-neuronales-recurrentes-rnn..html", "Capitulo7 Predicción con Redes Neuronales Recurrentes (RNN). 7.1 Introducción. 7.2 Objetivo. 7.3 Carga de datos desde Yahoo Finance. 7.4 Explicación. 7.5 Normalización y estructura de entrenamiento. 7.6 Explicación. 7.7 Implementación del modelo Elman. 7.8 Gráfica del modelo Elma. 7.9 Análisis. 7.10 Implementación del modelo Jordan. 7.11 Gráfica del modelo Jordan. 7.12 Análisis. 7.13 Conclusiones. 7.14 Importancia de las series de tiempo. 7.15 Recomendaciones finales.", " Capitulo7 Predicción con Redes Neuronales Recurrentes (RNN). 7.1 Introducción. En esta unidad aplicaremos algoritmos de inteligencia artificial, en particular redes neuronales recurrentes (RNN), para predecir valores futuros de una serie de tiempo financiera. Utilizaremos los modelos Elman y Jordan, los cuales tienen la capacidad de aprender patrones secuenciales a partir de los datos y permiten capturar dependencias temporales complejas. Este ejercicio representa el último avance en el proceso de modelado de series temporales que hemos venido documentando en este proyecto Bookdown. 7.2 Objetivo. Predecir valores futuros de la serie de precios de cierre de la acción de Apple Inc. (AAPL) usando modelos de redes neuronales recurrentes (Elman y Jordan), comparando su rendimiento y analizando su capacidad de modelado no lineal. 7.3 Carga de datos desde Yahoo Finance. # Descargar datos históricos desde Yahoo Finance datos_appl &lt;- tq_get(&quot;AAPL&quot;, from = &quot;2020-01-01&quot;, to = &quot;2025-04-30&quot;) # Vista previa head(datos_appl) symbol date open high low close volume adjusted AAPL 2020-01-02 74.0600 75.1500 73.7975 75.0875 135480400 72.62084 AAPL 2020-01-03 74.2875 75.1450 74.1250 74.3575 146322800 71.91483 AAPL 2020-01-06 73.4475 74.9900 73.1875 74.9500 118387200 72.48784 AAPL 2020-01-07 74.9600 75.2250 74.3700 74.5975 108872000 72.14695 AAPL 2020-01-08 74.2900 76.1100 74.2900 75.7975 132079200 73.30750 AAPL 2020-01-09 76.8100 77.6075 76.5500 77.4075 170108400 74.86463 7.4 Explicación. tq_get(“AAPL”, …): Esta función del paquete tidyquant permite obtener series de tiempo financieras directamente desde Yahoo Finance. En este caso se solicitan los datos de la acción de Apple Inc. con símbolo AAPL. from = “2020-01-01” y to = “2025-04-30”: Define el rango temporal que deseamos analizar. head(): Permite visualizar las primeras filas del dataset para asegurar que se haya descargado correctamente. 7.5 Normalización y estructura de entrenamiento. # Seleccionar columna de cierre y normalizar serie &lt;- datos_appl$close normalize &lt;- function(x) {(x - min(x)) / (max(x) - min(x))} serie_norm &lt;- normalize(serie) # Preparar datos con rezagos (lag) lag &lt;- 3 input &lt;- embed(serie_norm, lag + 1)[, -1] output &lt;- embed(serie_norm, lag + 1)[, 1] # Dividir en entrenamiento y prueba train_size &lt;- round(0.7 * nrow(input)) X_train &lt;- input[1:train_size, ] Y_train &lt;- output[1:train_size] X_test &lt;- input[(train_size + 1):nrow(input), ] Y_test &lt;- output[(train_size + 1):nrow(input)] 7.6 Explicación. Normalización: Es necesaria para que la red neuronal aprenda más eficientemente, ya que evita que las diferencias de escala entre los valores influyan en el aprendizaje. embed(): Esta función permite estructurar los datos en formato supervisado: los valores pasados (lag) se usan para predecir el siguiente. División 70/30: Se utiliza el 70% de los datos para entrenamiento y el 30% restante para prueba. 7.7 Implementación del modelo Elman. library(RSNNS) # Entrenar red Elman elman_model &lt;- elman(X_train, Y_train, size = c(10), learnFuncParams = c(0.1), maxit = 500, linOut = TRUE) # Predicciones pred_elman &lt;- predict(elman_model, X_test) # Desnormalizar denormalize &lt;- function(x, original) { x * (max(original) - min(original)) + min(original) } pred_elman_real &lt;- denormalize(pred_elman, serie) Y_test_real &lt;- denormalize(Y_test, serie) # Métrica de error mse_elman &lt;- mean((Y_test_real - pred_elman_real)^2) 7.8 Gráfica del modelo Elma. plot(Y_test_real, type = &quot;l&quot;, col = &quot;blue&quot;, lwd = 2, main = &quot;Predicción con Red Elman&quot;, xlab = &quot;Tiempo&quot;, ylab = &quot;Precio real&quot;) lines(pred_elman_real, col = &quot;red&quot;, lwd = 2) legend(&quot;topleft&quot;, legend = c(&quot;Real&quot;, &quot;Predicho&quot;), col = c(&quot;blue&quot;, &quot;red&quot;), lty = 1) 7.9 Análisis. La red Elman logra seguir razonablemente la tendencia de la serie de prueba. ##Visualmente, se observan desviaciones pequeñas en las zonas de mayor variación, lo que es esperable debido a la complejidad del mercado financiero. El error cuadrático medio (MSE) proporciona una medida cuantitativa del rendimiento y en este caso se encuentra dentro de rangos aceptables para tareas de predicción financiera. 7.10 Implementación del modelo Jordan. # Entrenar red Jordan jordan_model &lt;- jordan(X_train, Y_train, size = c(10), learnFuncParams = c(0.1), maxit = 500, linOut = TRUE) # Predicciones pred_jordan &lt;- predict(jordan_model, X_test) pred_jordan_real &lt;- denormalize(pred_jordan, serie) # Métrica de error mse_jordan &lt;- mean((Y_test_real - pred_jordan_real)^2) 7.11 Gráfica del modelo Jordan. plot(Y_test_real, type = &quot;l&quot;, col = &quot;blue&quot;, lwd = 2, main = &quot;Predicción con Red Jordan&quot;, xlab = &quot;Tiempo&quot;, ylab = &quot;Precio real&quot;) lines(pred_jordan_real, col = &quot;darkgreen&quot;, lwd = 2) legend(&quot;topleft&quot;, legend = c(&quot;Real&quot;, &quot;Predicho&quot;), col = c(&quot;blue&quot;, &quot;darkgreen&quot;), lty = 1) 7.12 Análisis. El modelo Jordan presenta un comportamiento similar al de Elman, con buena capacidad de seguimiento del comportamiento de la serie. Las diferencias entre ambos modelos suelen verse en la velocidad de adaptación a cambios bruscos. En este caso, el MSE también se encuentra en valores comparables, lo que indica un rendimiento competitivo. 7.13 Conclusiones. Las redes neuronales recurrentes son herramientas potentes para modelar series de tiempo, permitiendo capturar tanto patrones lineales como no lineales. Los modelos Elman y Jordan mostraron una buena capacidad de predicción sobre la serie AAPL. El uso de datos normalizados y una adecuada división entrenamiento/prueba contribuyen significativamente a la calidad del modelo. Las visualizaciones mostraron que ambas redes capturan bien la tendencia general, aunque con pequeñas diferencias en la respuesta ante picos. Este análisis cierra nuestro ciclo de aprendizaje en este curso, demostrando la utilidad de las RNN en series temporales reales de contexto financiero. 7.14 Importancia de las series de tiempo. A lo largo de las siete unidades desarrolladas en este proyecto, hemos explorado distintos enfoques para comprender, modelar y predecir series de tiempo. Desde la visualización inicial, pasando por el análisis de componentes como tendencia y estacionalidad, la verificación de estacionariedad, hasta la modelación con ARIMA, Prophet y redes neuronales, ha quedado en evidencia que las series de tiempo son herramientas fundamentales en el análisis predictivo. Su capacidad para capturar patrones temporales y su aplicabilidad a contextos reales —como mercados financieros, energía, salud o producción— las convierten en un recurso esencial en la toma de decisiones basada en datos. El dominio de técnicas de análisis de series de tiempo no solo permite entender el pasado, sino también anticipar el futuro, optimizar recursos y proponer estrategias fundamentadas. Este proyecto ha sido una muestra concreta de cómo, con datos reales y herramientas estadísticas y computacionales, se pueden generar modelos útiles para contextos complejos. 7.15 Recomendaciones finales. Continuar explorando modelos más avanzados de redes neuronales, como LSTM o GRU, especialmente útiles cuando existen secuencias largas y complejas. Incorporar variables exógenas o covariables si se desea mejorar la capacidad predictiva del modelo. Usar validación cruzada temporal para robustecer las conclusiones y evitar sobreajuste. Automatizar procesos de actualización del modelo si se trabajará en entornos productivos con datos que se actualizan periódicamente. Integrar visualizaciones interactivas para facilitar la comunicación de resultados a audiencias no técnicas. "],["bibliografía..html", "Capitulo8 Bibliografía.", " Capitulo8 Bibliografía. Yahoo Finance. (2025). Apple Inc. (AAPL) Stock Price &amp; Historical Data. Recuperado de https://finance.yahoo.com/quote/AAPL Dancho, M. &amp; Vaughan, D. (2021). tidyquant: Tidy Quantitative Financial Analysis. R package version 1.0.4. Recuperado de https://business-science.github.io/tidyquant/ Hyndman, R. J. &amp; Athanasopoulos, G. (2021). Forecasting: Principles and Practice (3ra ed.). OTexts. Disponible en https://otexts.com/fpp3/ Cowpertwait, P. &amp; Metcalfe, A. (2009). Introductory Time Series with R. Springer. DOI: 10.1007/978-0-387-88698-5 Shumway, R. H., &amp; Stoffer, D. S. (2017). Time Series Analysis and Its Applications: With R Examples (4ta ed.). Springer. R Core Team. (2023). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing. Disponible en https://www.R-project.org/ Analytics Vidhya. (2021). Holt-Winters Method for Time Series Analysis. Recuperado de: https://www.analyticsvidhya.com/blog/2021/08/holt-winters-method-for-time-series-analysis/ R Documentation. HoltWinters() y forecast packages. Recuperado de https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/HoltWinters Wickham, H., &amp; Grolemund, G. (2016). R for Data Science. O’Reilly Media. aylor, S. J. &amp; Letham, B. (2018). Forecasting at scale. The American Statistician, 72(1), 37–45. DOI: https://doi.org/10.1080/00031305.2017.1380080 Facebook Prophet Official Documentation: https://facebook.github.io/prophet/ Elman, J. L (1990). Finding structure in time. Cognitive Science, 14(2), 179–211. https://doi.org/10.1207/s15516709cog1402_1 Artículo original donde se presenta la red neuronal de tipo Elman, mostrando su capacidad para capturar secuencias temporales y estructuras lingüísticas. Jordan, M. I. (1986). Attractor dynamics and parallelism in a connectionist sequential machine. In Proceedings of the Eighth Annual Conference of the Cognitive Science Society (pp. 531–546). Trabajo fundacional que introduce las redes Jordan como una arquitectura para modelar secuencias de datos con retroalimentación desde la salida. Haykin, S. (2009). Neural Networks and Learning Machines (3rd ed.). Pearson Education. Texto clásico sobre redes neuronales, con capítulos dedicados a RNN y una explicación detallada de las arquitecturas Elman y Jordan. Schmidhuber, J. (2015). Deep learning in neural networks: An overview. Neural Networks, 61, 85–117. https://doi.org/10.1016/j.neunet.2014.09.003 Aunque enfocado en deep learning moderno, incluye una revisión de las redes recurrentes clásicas como Elman y Jordan en su evolución histórica. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
